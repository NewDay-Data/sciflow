# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/parse_module.ipynb.

# %% auto 0
__all__ = ['pp', 'extract_module_only', 'extract_step_code', 'FuncLister', 'FuncDetails', 'extract_return_stmt', 'parse_step',
           'extract_return_var_names', 'extract_steps']

# %% ../nbs/parse_module.ipynb 4
# | export

import ast
import os
import re
from dataclasses import dataclass
from pathlib import Path

import pandas as pd
from nbdev.export import get_config

# %% ../nbs/parse_module.ipynb 7
# | export


def extract_module_only(package_module_name):
    module_name = package_module_name
    if "." in module_name:
        package_name, module_name = module_name.split(".")
    return module_name

# %% ../nbs/parse_module.ipynb 11
# | export


def extract_step_code(
    module_path: Path,
    export_comments=("#|export", "#|exporti", "#|exports"),
    remove_comment_lines=True,
):
    with open(module_path, "r") as module_file:
        lines = module_file.readlines()
    lines = pd.Series(lines)
    step_code = {}
    active_step = None
    for l in lines.tolist():
        trimmed_line = l.lower().replace(" ", "")
        if trimmed_line.startswith("#|export_step"):
            active_step = trimmed_line.split("#|export_step")[1].strip()
        elif trimmed_line.startswith(export_comments):
            active_step = None
        if l.startswith("#") and remove_comment_lines:
            continue
        if active_step:
            if not active_step in step_code:
                step_code[active_step] = []
            step_code[active_step].append(l)
    for key in step_code.keys():
        step_code[key] = "".join(step_code[key])
    return step_code

# %% ../nbs/parse_module.ipynb 15
# | export


class FuncLister(ast.NodeVisitor):
    has_return = False

    def visit_Return(self, node):
        self.has_return = True

    def visit_FunctionDef(self, node):
        self.name = node.name
        self.docstring = ast.get_docstring(node)
        self.args = node.args.args
        self.arg_names = [a.arg for a in node.args.args]
        self.generic_visit(node)


import pprint

pp = pprint.PrettyPrinter(indent=4, width=120, compact=True)


@dataclass
class FuncDetails:
    name: str
    docstring: str
    args: str
    has_return: bool
    return_stmt: str
    code: str

    def __repr__(self):
        return pp.pformat(
            f"FuncDetails(name={self.name},args={self.args},has_return={self.has_return}):\n{self.code.strip()}"
        )

# %% ../nbs/parse_module.ipynb 18
# | export


def extract_return_stmt(func_name, code):
    return_stmt = [
        l.strip().split("return")[1].strip()
        for l in code.splitlines()
        if l.strip().startswith("return")
    ]
    if len(return_stmt) == 0:
        return
    return_stmt = return_stmt[0]
    is_named_variable = bool(re.search("^[a-zA-Z]+[a-zA-Z0-9_]*$", return_stmt))
    if not is_named_variable:
        raise NotImplementedError(
            f"Inline return statements are not supported. Assign the return value of {func_name} to a variable before returning."
        )
    return return_stmt

# %% ../nbs/parse_module.ipynb 23
# | export


def parse_step(step_code: str):
    tree = ast.parse(step_code)
    lister = FuncLister()
    lister.visit(tree)
    if "name" not in lister.__dict__:
        raise (
            ValueError("Step must have a single valid function; check step definition")
        )
    return FuncDetails(
        lister.name,
        lister.docstring,
        ",".join(lister.arg_names),
        lister.has_return,
        extract_return_stmt(lister.name, step_code),
        step_code,
    )

# %% ../nbs/parse_module.ipynb 25
# | export


def extract_return_var_names(step):
    tree = ast.parse(step.code)
    keys = []

    for node in ast.walk(tree):
        if isinstance(node, ast.Return):
            # Case 1: Direct dictionary return
            if isinstance(node.value, ast.Dict):
                for key in node.value.keys:
                    if isinstance(key, ast.Str):
                        keys.append(key.s)
                    elif isinstance(key, ast.Constant):  # For Python 3.8+
                        keys.append(key.value)

            # Case 2: Variable returning a dictionary
            elif isinstance(node.value, ast.Name):
                var_name = node.value.id
                # Now, find the assignment of this variable in the code
                for assign_node in ast.walk(tree):
                    if isinstance(assign_node, ast.Assign):
                        for target in assign_node.targets:
                            if isinstance(target, ast.Name) and target.id == var_name:
                                if isinstance(assign_node.value, ast.Dict):
                                    for key in assign_node.value.keys:
                                        if isinstance(key, ast.Str):
                                            keys.append(key.s)
                                        elif isinstance(
                                            key, ast.Constant
                                        ):  # For Python 3.8+
                                            keys.append(key.value)

    return keys

# %% ../nbs/parse_module.ipynb 31
# | export


def extract_steps(module_path: Path):
    step_code = extract_step_code(module_path)
    steps = [parse_step(step_code[k]) for k in step_code.keys()]
    return steps

# %% ../nbs/parse_module.ipynb 33
# | export


def _convert_return_stmt(numbered_step):
    number, step = numbered_step
    step["return_stmt"] = "" if not step["return_stmt"] else step["return_stmt"]
    return number, step
