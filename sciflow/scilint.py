# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/scilint.ipynb (unless otherwise specified).

__all__ = ['run_nbqa_cmd', 'sciflow_tidy', 'get_function_defs', 'count_func_calls', 'calc_tpf', 'tpf', 'something',
           'nb_to_sagemaker_pipeline', 'nb_cell_code', 'x', 'ifp', 'mcp', 'tcl', 'lint_nb', 'format_quality_warning',
           'lint_nbs']

# Cell

import ast
import astunparse
import os
from collections import Counter
from pathlib import Path

import numpy as np
import pandas as pd
import nbformat
from fastcore.script import call_parse
from nbdev.export import read_nb, nbglob
from nbqa.__main__ import _get_configs, _main
from nbqa.cmdline import CLIArgs
from nbqa.find_root import find_project_root

from .utils import load_nb_module

# Cell


def run_nbqa_cmd(cmd):
    print(f"Running {cmd}")
    project_root: Path = find_project_root(tuple([str(Path(".").resolve())]))
    args = CLIArgs.parse_args([cmd, str(project_root)])
    configs = _get_configs(args, project_root)
    output_code = _main(args, configs)
    return output_code

# Cell


@call_parse
def sciflow_tidy():
    """
    Run notebook formatting and tidy utilities.
    These tools should be configured to run automatically without intervention."
    """
    tidy_tools = ["black", "isort", "autoflake"]
    [run_nbqa_cmd(c) for c in tidy_tools]

# Cell


def get_function_defs(code):
    func_names = []
    for stmt in ast.walk(ast.parse(code)):
        if isinstance(stmt, ast.FunctionDef) and not stmt.name.startswith("_"):
            func_names.append(stmt.name)
    return func_names

# Cell


def count_func_calls(code, func_defs):
    func_calls = Counter({k: 0 for k in func_defs})
    for stmt in ast.walk(ast.parse(code)):
        if isinstance(stmt, ast.Call):
            func_name = stmt.func.id if "id" in stmt.func.__dict__ else stmt.func.attr
            if func_name in func_defs:
                if func_name in func_calls:
                    func_calls[func_name] += 1
    return func_calls

# Cell


def calc_tpf(num_tests, num_funcs):
    return 0 if num_funcs == 0 else num_tests / num_funcs

# Cell


def tpf(nb, module_code):
    pnb = nbformat.from_dict(nb)
    nb_cell_code = "\n".join(
        [c["source"].replace("%", "#") for c in pnb.cells if c["cell_type"] == "code"]
    )
    func_defs = get_function_defs(module_code)
    func_calls = count_func_calls(nb_cell_code, func_defs)
    num_funcs = len(func_calls.keys())
    num_tests = sum(func_calls.values())
    return calc_tpf(num_tests, num_funcs)

# Cell
nb_cell_code = r"""
def something():
    pass; pass # in x 2

#load_ext autoreload
#autoreload 2
# export

import pandas as pd # out
from .utils import lib_path, odbc_connect, query # out

# export

def nb_to_sagemaker_pipeline(
    nb_path: Path,
    silent: bool = True,
):
    nb = read_nb(nb_path)  # in
    lib_name = get_config().get("lib_name")  # in
    module_name = find_default_export(nb["cells"])  # in

x = [1,2,3] # out
nb_to_sagemaker_pipeline() # out
"""

# Cell


def ifp(nb):
    nb_cell_code = "\n".join(
        [c["source"].replace("%", "#") for c in nb.cells if c["cell_type"] == "code"]
    )
    return calc_ifp(nb_cell_code)

# Cell


def mcp(nb):
    md_cells = [c for c in nb.cells if c["cell_type"] == "markdown"]
    code_cells = [c for c in nb.cells if c["cell_type"] == "code"]
    num_code_cells = len(code_cells)
    num_md_cells = len(md_cells)
    return 0 if num_code_cells == 0 else (num_md_cells / (num_md_cells + num_code_cells)) * 100

# Cell


def tcl(nb):
    return sum([len(c["source"]) for c in nb.cells if c["cell_type"] == "code"])

# Cell


def lint_nb(nb_path, tpf_warn_thresh=None, ifp_warn_thresh=None, mcp_warn_thresh=None, tcl_warn_thresh=None, rounding_precision=3):
    result = (np.nan, np.nan, np.nan, np.nan)
    try:
        nb, module_code = load_nb_module(nb_path)
    except ValueError as ve:
        #print(f"Skipping notebook with no associated module: {nb_path.name}")
        return result
    nb_tpf = round(tpf(nb, module_code), rounding_precision)
    nb_ifp = round(ifp(nb), rounding_precision)
    nb_mcp = round(mcp(nb), rounding_precision)
    nb_tcl = round(tcl(nb), rounding_precision)
    #print(f"NB: {nb_path.name} TestsPerFunction: {nb_tpf} In-FunctionPercent: {nb_ifp} MarkdownToCodeRatio: {nb_mcr} TotalCodeLen: {nb_tcl}")
    return (nb_tpf, nb_ifp, nb_mcp, nb_tcl)


# Cell


def format_quality_warning(metric, warning_data, warn_thresh, direction):
    for warning_row in warning_data.reset_index().itertuples():
        print(f"\"{warning_row.index}\" has: {metric} {direction} {warn_thresh}")

# Cell


def lint_nbs(tpf_warn_thresh=1, ifp_warn_thresh=10, mcp_warn_thresh=5, tcl_warn_thresh=20000, rounding_precision=3):
    nb_paths = nbglob(recursive=True)
    lt_metric_cols = ['tests_per_function', 'in_function_percent', 'markdown_code_percent']
    gt_metric_cols = ['total_code_len']
    lt_metrics_thresholds = [tpf_warn_thresh, ifp_warn_thresh, mcp_warn_thresh]
    gt_metrics_thresholds = [tcl_warn_thresh]
    results = []
    nb_names = []
    for nb_path in nb_paths:
        nb_names.append(nb_path.stem)
        results.append(lint_nb(nb_path))
    lint_report = pd.DataFrame.from_records(data=results,
                                        index=nb_names,
                                        columns=lt_metric_cols+gt_metric_cols).sort_values(['tests_per_function', 'markdown_code_percent'], ascending=False)

    print("\n********************************Begin Scilint Report********************************")
    for lt_metric_col, lt_metrics_threshold in zip(lt_metric_cols, lt_metrics_thresholds):
        metrics_series = lint_report[lt_metric_col]
        format_quality_warning(lt_metric_col, metrics_series[metrics_series < lt_metrics_threshold], lt_metrics_threshold, direction="<")
    for gt_metric_col, gt_metrics_threshold in zip(gt_metric_cols, gt_metrics_thresholds):
        metrics_series = lint_report[gt_metric_col]
        format_quality_warning(gt_metric_col, metrics_series[metrics_series > gt_metrics_threshold], gt_metrics_threshold, direction=">")
    print("\n********************************End Scilint Report********************************")

    return lint_report