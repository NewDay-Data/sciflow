# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/utils.ipynb.

# %% auto 0
__all__ = ['run_shell_cmd', 'indent_multiline', 'titleize', 'chunks', 'lib_path', 'find_default_export', 'load_nb',
           'load_nb_module', 'prepare_env', 'get_module_name', 'get_flow_path']

# %% ../nbs/utils.ipynb 2
# | export

import _ast
import ast
import os
import subprocess
import sys
from pathlib import Path
from typing import Tuple

from execnb.nbio import read_nb
from fastcore.basics import AttrDict
from nbdev.config import get_config
from nbqa.find_root import find_project_root

# %% ../nbs/utils.ipynb 5
# | export


def run_shell_cmd(script: str):
    pipe = subprocess.Popen(
        "%s" % script, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, shell=True
    )
    output = pipe.communicate()[0]
    return pipe, output.decode("utf-8").strip()

# %% ../nbs/utils.ipynb 8
# | export


def indent_multiline(multiline_text, indent=1):
    lines = multiline_text.strip().split("\n")
    spaces = "".join(["    " for _ in range(indent)])
    for i in range(len(lines)):
        prefix = spaces if i > 0 else spaces + '"""'
        lines[i] = prefix + lines[i]
    return "\n".join(lines) + '"""'

# %% ../nbs/utils.ipynb 11
# | export


def titleize(name):
    return name.title().replace("_", "")

# %% ../nbs/utils.ipynb 14
# | export


def chunks(lst, n):
    """Yield successive n-sized chunks from lst."""
    for i in range(0, len(lst), n):
        yield lst[i : i + n]

# %% ../nbs/utils.ipynb 16
# | export


def lib_path(*lib_relative_path):
    lib_root_path = find_project_root(srcs=(str(Path(".").resolve()),))
    return Path(os.path.join(lib_root_path, *lib_relative_path))

# %% ../nbs/utils.ipynb 19
# | export


def find_default_export(cells):
    default_export = None
    cell_lines = [c["source"].split("\n") for c in cells]
    for cell in cell_lines:
        for line in cell:
            trimmed_line = line.strip().replace(" ", "")
            if trimmed_line.startswith("#|default_exp"):
                default_export = trimmed_line.split("#|default_exp")[1].strip()
    return default_export

# %% ../nbs/utils.ipynb 20
# | export


def load_nb(nb_path: Path) -> Tuple[AttrDict, Path]:
    nb = read_nb(nb_path)
    default_export = find_default_export(nb["cells"])
    if default_export is None:
        raise ValueError(f"{nb_path.name} does not contain an associated nbdev module")

    module_name = default_export.replace(".", "/")
    module_path = Path(get_config().path("lib_path"), f"{module_name}.py")
    return nb, module_path

# %% ../nbs/utils.ipynb 24
# | export


def load_nb_module(nb_path):
    nb, module_path = load_nb(nb_path)
    with open(module_path, "r") as module_file:
        lines = module_file.readlines()
    module_code = "\n".join(lines)
    return nb, module_code

# %% ../nbs/utils.ipynb 27
# | export


def prepare_env(env_file_path: str = None):
    if env_file_path is None:
        env_file_path = os.path.expanduser("~/.sciflow/env")
    if not os.path.exists(env_file_path):
        raise EnvironmentError(
            f"You need to create a Sciflow environment vars file at: {env_file_path}"
        )
    with open(env_file_path, "r") as env_file:
        for line in env_file.readlines():
            key, value = line.strip().split("=", 1)
            os.environ[key.replace("export ", "")] = value
        python_path = [
            p for p in os.environ["PYTHONPATH"].split(":") if p != "$PYTHONPATH"
        ]
        sys.path.extend(python_path)

# %% ../nbs/utils.ipynb 29
# | export


def get_module_name(nb_path):
    nb = read_nb(nb_path)
    module_name = find_default_export(nb["cells"])
    return module_name

# %% ../nbs/utils.ipynb 30
# | export


def get_flow_path(nb_path, config=None, flow_provider="metaflow"):
    module_name = get_module_name(nb_path)
    if module_name is None:
        return None
    if config is None:
        config = get_config()
    flows_dir = Path(config.path("flows_path"), flow_provider)
    if not flows_dir.exists():
        flows_dir.mkdir(parents=True)

    return Path(flows_dir, f"{module_name.split('.')[-1]}.py")
