# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/run_flow.ipynb (unless otherwise specified).

__all__ = ['run_shell_cmd', 'check_call_flow', 'run_flow', 'check_flows']

# Cell


import asyncio
import multiprocessing
import os
import subprocess
import sys
from itertools import product
from pathlib import Path, PosixPath
from typing import Any, Dict, Iterable

import pandas as pd
from fastcore.script import Param, call_parse
from nbdev.export import find_default_export, get_config, nbglob, read_nb

from .data_handler import extract_param_meta
from .params import params_as_dict
from .parse_module import FuncDetails, extract_steps
from .utils import prepare_env, get_flow_path

# Cell


def run_shell_cmd(script: str):
    pipe = subprocess.Popen("%s" % script, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, shell=True)
    output = pipe.communicate()[0]
    return pipe, output.decode("utf-8").strip()

# Cell

def check_call_flow(flow_nb_path, flow_provider="metaflow", flow_command="show", params=None):
    prepare_env()
    if flow_nb_path.suffix == ".ipynb":
        flow_path = get_flow_path(nb_path, flow_provider=flow_provider)
    else:
        flow_path = flow_nb_path
    if params:
        args = " ".join([f"--{p[0]} {p[1]}" for p in params])
        flow_command = f"{flow_command} {args}"

    script = f"python '{flow_path}' {flow_command}"
    pipe, output = run_shell_cmd(script)
    return pipe.returncode, output

# Cell


def run_flow(nb_path, flow_provider='metaflow', flow_command="--no-pylint run", params=None):
    flow_path = get_flow_path(nb_path, flow_provider=flow_provider)
    print(f"Running flow: {os.path.basename(flow_path)}")
    ret_code, output = check_flow(
        flow_path.parent,
        os.path.basename(flow_path),
        flow_provider=flow_provider,
        flow_command=flow_command,
        params=params,
    )
    return ret_code, output

# Cell


def check_flows(
    config, flow_provider = 'metaflow', flow_command="show", ignore_suffix="_no_params.py", exit_on_error=True
):
    flow_results = {}
    flows_dir = Path(config.path("flows_path"), flow_provider)

    if ignore_suffix:
        flow_file_names = [p for p in os.listdir(flows_dir) if not p.endswith(ignore_suffix)]
    else:
        flow_file_names = os.listdir(flows_dir)
    ret_codes = []
    exit_code = 0
    for flow_file_name in flow_file_names:
        flow_name = os.path.basename(flow_file_name)
        if flow_file_name.startswith('_sciflow'):
            print('Skippping Sciflow generatedmodule')
        if flow_file_name.endswith(".py"):
            ret_code, output = check_call_flow(Path(flows_dir, flow_file_name), flow_command=flow_command)
            flow_results[flow_name] = ret_code, output
            if ret_code == 0:
                print(f"Flow: {flow_name} {flow_command} verified")
            else:
                print(
                    f"Flow: {flow_name} {flow_command} verification failed\nDetails:\n{output}"
                )
            ret_codes.append(ret_code)
    if any([rc != 0 for rc in ret_codes]):
        exit_code = 1
        try:
            # Exit with an error code if running from a non interactive Python environment.
            get_ipython().__class__.__name__
        except NameError:
            if exit_on_error:
                return sys.exit(exit_code)
    return exit_code