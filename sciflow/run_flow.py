# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/run_flow.ipynb (unless otherwise specified).

__all__ = ['run_shell_cmd', 'check_call_flow', 'check_call_flows', 'run_flow_task', 'run_flow_async', 'iter_param_grid',
           'sample_grid_space', 'search_flow_grid', 'sciflow_check_flows', 'sciflow_run_flows']

# Cell


import asyncio
import multiprocessing
import os
import subprocess
import sys
from itertools import product
from pathlib import Path, PosixPath
from typing import Any, Dict, Iterable

import pandas as pd
from fastcore.script import Param, call_parse
from nbdev.export import find_default_export, get_config, nbglob, read_nb

from .data_handler import extract_param_meta
from .params import params_as_dict
from .parse_module import FuncDetails, extract_steps
from .utils import prepare_env, get_flow_path

# Cell


def run_shell_cmd(script: str):
    pipe = subprocess.Popen("%s" % script, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, shell=True)
    output = pipe.communicate()[0]
    return pipe, output.decode("utf-8").strip()

# Cell

def check_call_flow(flow_nb_path, flow_provider="metaflow", flow_command="show", params=None):
    prepare_env()
    if flow_nb_path.suffix == ".ipynb":
        flow_path = get_flow_path(nb_path, flow_provider=flow_provider)
    else:
        flow_path = flow_nb_path
    if params:
        args = " ".join([f"--{p[0]} {p[1]}" for p in params])
        flow_command = f"{flow_command} {args}"

    script = f"python '{flow_path}' {flow_command}"
    pipe, output = run_shell_cmd(script)
    return pipe.returncode, output

# Cell


def check_call_flows(
    config, flow_provider = 'metaflow', flow_command="show", ignore_suffix=None, exit_on_error=True
):
    flow_results = {}
    flows_dir = Path(config.path("flows_path"), flow_provider)

    if ignore_suffix:
        flow_file_names = [p for p in os.listdir(flows_dir) if not p.endswith(ignore_suffix)]
    else:
        flow_file_names = os.listdir(flows_dir)
    ret_codes = []
    exit_code = 0
    for flow_file_name in flow_file_names:
        flow_name = os.path.basename(flow_file_name)
        if flow_file_name.startswith('_sciflow'):
            continue
        if flow_file_name.endswith(".py"):
            ret_code, output = check_call_flow(Path(flows_dir, flow_file_name), flow_command=flow_command)
            flow_results[flow_name] = ret_code, output
            if ret_code == 0:
                print(f"Flow: {flow_name} {flow_command} verified")
            else:
                print(
                    f"Flow: {flow_name} {flow_command} verification failed\nDetails:\n{output}"
                )
            ret_codes.append(ret_code)
    if any([rc != 0 for rc in ret_codes]):
        exit_code = 1
        try:
            # Exit with an error code if running from a non interactive Python environment.
            get_ipython().__class__.__name__
        except NameError:
            if exit_on_error:
                return sys.exit(exit_code)
    return exit_code

# Cell


async def run_flow_task(flow_path, param_grid=None):
    flows_dir = flow_path.parent
    flow_module = os.path.basename(flow_path)
    flow_command = "--no-pylint run"
    prep_mf_env()
    if params:
        args = " ".join([f"--{k} {v}" for k, v in param_grid.items()])
        cmd = f"python '{os.path.join(flows_dir, flow_module)}' {flow_command} {args}"
    else:
        cmd = f"python '{os.path.join(flows_dir, flow_module)}' {flow_command}"
    proc = await asyncio.create_subprocess_shell(
        cmd, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE
    )

    stdout, stderr = await proc.communicate()

    print(f"[{cmd!r} exited with {proc.returncode}]")
    if stdout:
        output = stdout.decode("utf-8").strip()
        print(f"[stdout]\n{output}")
    if stderr:
        print(f'[stderr]\n{stderr.decode("utf-8").strip()}')

    return proc.returncode

# Cell


def run_flow_async(nb_path, params=None):
    flow_path = get_flow_path(nb_path)
    loop = asyncio.get_event_loop()
    task = loop.create_task(run_flow_task(flow_path, params))
    return task

# Cell


def iter_param_grid(param_grid):
    # https://github.com/scikit-learn/scikit-learn/blob/main/sklearn/model_selection/_search.py
    for p in [param_grid]:
        # Always sort the keys of a dictionary, for reproducibility
        items = sorted(p.items())
        if not items:
            yield {}
        else:
            keys, values = zip(*items)
            for v in product(*values):
                params = dict(zip(keys, v))
                yield params

# Cell


def sample_grid_space(param_grid: Dict[str, Iterable[Any]], num_samples: int):
    samples = []
    for i, sample in enumerate(iter_param_grid(param_grid)):
        samples.append(sample)
    if num_samples < len(samples):
        samples = pd.Series(samples).sample(num_samples).tolist()
    return samples

# Cell


def search_flow_grid(nb_path, param_grid, num_procs=None):
    if num_procs is None:
        num_procs = int((multiprocessing.cpu_count() / 2) - 1)

    param_sample_space = sample_grid_space(param_grid, num_procs)
    tasks = []
    for param_sample in param_sample_space:
        tasks.append(run_flow_async(nb_path, params=param_sample))
    return tasks

# Cell


@call_parse
def sciflow_check_flows():
    check_flows(get_config())

# Cell


@call_parse
def sciflow_run_flows():
    check_flows(get_config(), "--no-pylint run")